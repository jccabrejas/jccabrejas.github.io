<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Image Splitter Tool</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        .day-card { transition: all 0.2s ease; }
        .day-card:hover { transform: translateY(-2px); }
        .rest-day { background-color: #f3f4f6; color: #9ca3af; }
        .active-day { background-color: #ffffff; border-left: 4px solid #3b82f6; }
        .custom-scrollbar::-webkit-scrollbar { width: 6px; }
        .custom-scrollbar::-webkit-scrollbar-thumb { background: #cbd5e1; border-radius: 10px; }
    </style>
</head>
<body class="bg-slate-50 min-h-screen font-sans text-slate-900">

    <div class="max-w-5xl mx-auto py-10 px-4">
        <header class="mb-10 text-center">
            <h1 class="text-4xl font-extrabold text-slate-800 tracking-tight mb-2">Image Splitter Tool</h1>
            <p class="text-slate-600">Split photos into multiple parts with predefined settings.</p>
            <button id="viewPromptBtn" class="mt-4 bg-blue-500 text-white px-4 py-2 rounded hover:bg-blue-600 transition">View AI Prompt</button>
        </header>

        <div class="bg-white p-6 rounded-2xl shadow-sm border border-slate-200">
            <div class="control-group mb-6">
                <label for="fileInput" class="block text-sm font-bold uppercase tracking-wider text-slate-500 mb-2">1. Select Photo</label>
                <input type="file" id="fileInput" accept="image/*" class="w-full p-3 bg-slate-50 border border-slate-200 rounded-xl focus:ring-2 focus:ring-blue-500 outline-none">
                <div class="paste-area border-2 border-dashed border-slate-300 p-4 text-center text-slate-400 bg-slate-50 rounded-xl mt-2">or paste an image here (Ctrl+V / Cmd+V)</div>
            </div>

            <div class="control-group mb-6">
                <label for="fileNameTemplate" class="block text-sm font-bold uppercase tracking-wider text-slate-500 mb-2">2. Filename Template</label>
                <input type="text" id="fileNameTemplate" placeholder="e.g., my-vacation-split" value="split-image" class="w-full p-3 bg-slate-50 border border-slate-200 rounded-xl focus:ring-2 focus:ring-blue-500 outline-none">
            </div>

            <div class="control-group mb-6">
                <label class="block text-sm font-bold uppercase tracking-wider text-slate-500 mb-2">3. Choose Split Mode</label>
                <div class="flex gap-2 justify-center">
                    <button id="btn3H" disabled class="bg-slate-400 text-white px-4 py-2 rounded-xl font-bold hover:bg-slate-500 transition disabled:bg-slate-200">3 Horizontal Strips</button>
                    <button id="btn3V" disabled class="bg-slate-400 text-white px-4 py-2 rounded-xl font-bold hover:bg-slate-500 transition disabled:bg-slate-200">3 Vertical Strips</button>
                    <button id="btnGrid" disabled class="bg-slate-400 text-white px-4 py-2 rounded-xl font-bold hover:bg-slate-500 transition disabled:bg-slate-200">4 Photos (2x2 Grid)</button>
                </div>
            </div>

            <div id="editor-section" class="hidden space-y-4">
                <h3 class="text-lg font-bold text-slate-800">Review and Adjust Guidelines</h3>
                <p class="text-slate-600 text-sm">Drag the cyan lines to adjust cuts.</p>
                <div class="canvas-container border-2 border-slate-200 rounded-xl overflow-auto max-h-96 cursor-crosshair">
                    <canvas id="imageCanvas" class="block"></canvas>
                </div>
                <div class="flex gap-2 justify-center">
                    <button id="generateBtn" class="bg-blue-600 text-white px-4 py-2 rounded-xl font-bold hover:bg-blue-500 transition">Generate Subphotos</button>
                    <button id="cancelBtn" class="bg-slate-500 text-white px-4 py-2 rounded-xl font-bold hover:bg-slate-400 transition">Cancel</button>
                </div>
            </div>

            <div id="results-section" class="hidden space-y-4">
                <h3 class="text-lg font-bold text-slate-800">Results</h3>
                <div class="flex gap-2 justify-center">
                    <button id="downloadAllBtn" class="bg-emerald-600 text-white px-4 py-2 rounded-xl font-bold hover:bg-emerald-500 transition">Download All</button>
                    <button id="newImageBtn" class="bg-slate-500 text-white px-4 py-2 rounded-xl font-bold hover:bg-slate-400 transition">Start Over</button>
                </div>
                <div class="thumbnails-grid grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-4" id="thumbnailsContainer">
                </div>
            </div>
        </div>
    </div>


<script>
    // === Elements ===
    const fileInput = document.getElementById('fileInput');
    const templateInput = document.getElementById('fileNameTemplate');
    const btn3H = document.getElementById('btn3H');
    const btn3V = document.getElementById('btn3V');
    const btnGrid = document.getElementById('btnGrid');
    const editorSection = document.getElementById('editor-section');
    const resultsSection = document.getElementById('results-section');
    const canvas = document.getElementById('imageCanvas');
    const ctx = canvas.getContext('2d');
    const generateBtn = document.getElementById('generateBtn');
    const cancelBtn = document.getElementById('cancelBtn');
    const thumbnailsContainer = document.getElementById('thumbnailsContainer');
    const downloadAllBtn = document.getElementById('downloadAllBtn');
    const newImageBtn = document.getElementById('newImageBtn');

    // === State ===
    let loadedImage = null;
    let currentMode = null; // '3H', '3V', 'GRID'
    // Arrays to store normalized positions (0.0 to 1.0) of the guides
    let hGuides = []; 
    let vGuides = [];
    let isDragging = false;
    let draggedGuide = null; // { type: 'h' or 'v', index: 0 }
    const guideHitTolerance = 10; // pixels space around line to grab it
    let generatedBlobs = []; // Store generated images ready for download

    // === Event Listeners: Image Loading ===

    // Handle File Input
    fileInput.addEventListener('change', (e) => {
        if (e.target.files && e.target.files[0]) {
            loadImage(e.target.files[0]);
        }
    });

    // Handle Paste
    document.addEventListener('paste', (e) => {
        const items = (e.clipboardData || e.originalEvent.clipboardData).items;
        for (let item of items) {
            if (item.type.indexOf('image') === 0) {
                const blob = item.getAsFile();
                loadImage(blob);
                // Clear file input value so paste takes precedence visually if needed
                fileInput.value = ''; 
                return;
            }
        }
    });

    function loadImage(file) {
        const reader = new FileReader();
        reader.onload = (event) => {
            const img = new Image();
            img.onload = () => {
                loadedImage = img;
                enableModeButtons();
                resetUIState();
            };
            img.src = event.target.result;
        };
        reader.readAsDataURL(file);
    }

    function enableModeButtons() {
        btn3H.disabled = false;
        btn3H.className = 'bg-blue-600 text-white px-4 py-2 rounded-xl font-bold hover:bg-blue-500 transition';
        btn3V.disabled = false;
        btn3V.className = 'bg-blue-600 text-white px-4 py-2 rounded-xl font-bold hover:bg-blue-500 transition';
        btnGrid.disabled = false;
        btnGrid.className = 'bg-blue-600 text-white px-4 py-2 rounded-xl font-bold hover:bg-blue-500 transition';
    }

    function resetUIState() {
        editorSection.classList.add('hidden');
        resultsSection.classList.add('hidden');
        generatedBlobs = [];
        btn3H.disabled = true;
        btn3H.className = 'bg-slate-400 text-white px-4 py-2 rounded-xl font-bold disabled:bg-slate-200';
        btn3V.disabled = true;
        btn3V.className = 'bg-slate-400 text-white px-4 py-2 rounded-xl font-bold disabled:bg-slate-200';
        btnGrid.disabled = true;
        btnGrid.className = 'bg-slate-400 text-white px-4 py-2 rounded-xl font-bold disabled:bg-slate-200';
    }

    // === Event Listeners: Mode Selection ===
    btn3H.addEventListener('click', () => setupEditor('3H'));
    btn3V.addEventListener('click', () => setupEditor('3V'));
    btnGrid.addEventListener('click', () => setupEditor('GRID'));

    function setupEditor(mode) {
        currentMode = mode;
        editorSection.classList.remove('hidden');
        resultsSection.classList.add('hidden');

        // Set canvas dimensions to match loaded image
        canvas.width = loadedImage.width;
        canvas.height = loadedImage.height;

        // Initialize guides based on mode (normalized 0.0 - 1.0)
        hGuides = [];
        vGuides = [];
        if (mode === '3H') {
            hGuides = [1/3, 2/3];
        } else if (mode === '3V') {
            vGuides = [1/3, 2/3];
        } else if (mode === 'GRID') {
            hGuides = [0.5];
            vGuides = [0.5];
        }

        drawCanvas();
    }

    // === Canvas Drawing & Interaction ===

    function drawCanvas() {
        if (!loadedImage) return;
        
        // 1. Clear & Draw Image
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.drawImage(loadedImage, 0, 0);

        // 2. Set Guide styles
        ctx.strokeStyle = 'cyan';
        ctx.lineWidth = 3;
        ctx.setLineDash([5, 3]); // Dashed lines for better visibility

        // 3. Draw Horizontal Guides
        for (let pos of hGuides) {
            const y = pos * canvas.height;
            ctx.beginPath();
            ctx.moveTo(0, y);
            ctx.lineTo(canvas.width, y);
            ctx.stroke();
        }

        // 4. Draw Vertical Guides
        for (let pos of vGuides) {
            const x = pos * canvas.width;
            ctx.beginPath();
            ctx.moveTo(x, 0);
            ctx.lineTo(x, canvas.height);
            ctx.stroke();
        }
    }

    // Mouse Interaction for Dragging
    canvas.addEventListener('mousedown', (e) => {
        const rect = canvas.getBoundingClientRect();
        // Calculate scale factor in case canvas is displayed smaller than actual size via CSS
        const scaleX = canvas.width / rect.width;
        const scaleY = canvas.height / rect.height;
        const mouseX = (e.clientX - rect.left) * scaleX;
        const mouseY = (e.clientY - rect.top) * scaleY;

        // Check Horizontal guides hit
        for (let i = 0; i < hGuides.length; i++) {
            const y = hGuides[i] * canvas.height;
            if (Math.abs(mouseY - y) < guideHitTolerance) {
                isDragging = true;
                draggedGuide = { type: 'h', index: i };
                return;
            }
        }

        // Check Vertical guides hit
        for (let i = 0; i < vGuides.length; i++) {
            const x = vGuides[i] * canvas.width;
            if (Math.abs(mouseX - x) < guideHitTolerance) {
                isDragging = true;
                draggedGuide = { type: 'v', index: i };
                return;
            }
        }
    });

    canvas.addEventListener('mousemove', (e) => {
        // Change cursor if hovering over a guide
        const rect = canvas.getBoundingClientRect();
        const scaleX = canvas.width / rect.width;
        const scaleY = canvas.height / rect.height;
        const mouseX = (e.clientX - rect.left) * scaleX;
        const mouseY = (e.clientY - rect.top) * scaleY;
        
        let cursor = 'crosshair';
        if(!isDragging) {
             for (let pos of hGuides) {
                 if (Math.abs(mouseY - (pos * canvas.height)) < guideHitTolerance) cursor = 'row-resize';
             }
             for (let pos of vGuides) {
                 if (Math.abs(mouseX - (pos * canvas.width)) < guideHitTolerance) cursor = 'col-resize';
             }
        }
        canvas.style.cursor = cursor;

        if (!isDragging || !draggedGuide) return;

        if (draggedGuide.type === 'h') {
            // Normalize new Y position, constrain within bounds
            let newPos = mouseY / canvas.height;
            newPos = Math.max(0.01, Math.min(0.99, newPos)); // Keep slightly inside
            hGuides[draggedGuide.index] = newPos;
        } else {
             // Normalize new X position
            let newPos = mouseX / canvas.width;
            newPos = Math.max(0.01, Math.min(0.99, newPos));
            vGuides[draggedGuide.index] = newPos;
        }
        drawCanvas();
    });

    document.addEventListener('mouseup', () => {
        isDragging = false;
        draggedGuide = null;
    });

    cancelBtn.addEventListener('click', resetUIState);


    // === Generation & Slicing Logic ===

    generateBtn.addEventListener('click', () => {
        generatedBlobs = [];
        const regions = calculateRegions();
        
        // Use an off-screen canvas to slice chunks
        const sliceCanvas = document.createElement('canvas');
        const sliceCtx = sliceCanvas.getContext('2d');

        let processedCount = 0;

        regions.forEach((region, index) => {
            // Set small canvas to region size
            sliceCanvas.width = region.w;
            sliceCanvas.height = region.h;
            
            // Draw just that part of the source image onto small canvas
            // drawImage(source, srcX, srcY, srcW, srcH, destX, destY, destW, destH)
            sliceCtx.drawImage(
                loadedImage, 
                region.x, region.y, region.w, region.h, 
                0, 0, region.w, region.h
            );

            // Convert to blob for download/display
            sliceCanvas.toBlob((blob) => {
                generatedBlobs.push({ blob, index });
                processedCount++;
                if (processedCount === regions.length) {
                    // Ensure they stay in order
                    generatedBlobs.sort((a, b) => a.index - b.index);
                    displayResults();
                }
            }, 'image/png'); // Defaulting to PNG for simplicity
        });
    });

    function calculateRegions() {
        const w = canvas.width;
        const h = canvas.height;
        let regions = []; // {x, y, w, h}

        // Sort guides to ensure correct slicing order
        const sortedH = [0, ...hGuides.sort(), 1].map(p => p * h);
        const sortedV = [0, ...vGuides.sort(), 1].map(p => p * w);

        // Iterate through the grid defined by the guides
        for (let i = 0; i < sortedH.length - 1; i++) {
            const yStart = sortedH[i];
            const yEnd = sortedH[i+1];
            const height = yEnd - yStart;

            for (let j = 0; j < sortedV.length - 1; j++) {
                const xStart = sortedV[j];
                const xEnd = sortedV[j+1];
                const width = xEnd - xStart;

                regions.push({ x: xStart, y: yStart, w: width, h: height });
            }
        }
        return regions;
    }


    // === Display & Download ===

    function displayResults() {
        editorSection.classList.add('hidden');
        resultsSection.classList.remove('hidden');
        thumbnailsContainer.innerHTML = '';

        generatedBlobs.forEach((item, i) => {
            const url = URL.createObjectURL(item.blob);
            
            const div = document.createElement('div');
            div.className = 'thumbnail-item text-center border border-slate-200 p-4 rounded-xl';
            
            const img = document.createElement('img');
            img.src = url;
            img.className = 'w-full h-auto rounded-lg mb-2 shadow-sm';
            
            const btn = document.createElement('button');
            btn.textContent = `Download #${i+1}`;
            btn.className = 'bg-slate-500 text-white px-3 py-1 rounded font-bold hover:bg-slate-400 transition text-sm';
            btn.onclick = () => downloadSingle(item.blob, i);

            div.appendChild(img);
            div.appendChild(btn);
            thumbnailsContainer.appendChild(div);
        });
    }

    function getBaseFilename() {
        let template = templateInput.value.trim() || 'split-image';
        // Remove invalid filename characters
        template = template.replace(/[^a-z0-9_\-]/gi, '_');
        const timestamp = new Date().getTime();
        return `${template}_${timestamp}`;
    }

    function downloadSingle(blob, index) {
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.style.display = 'none';
        a.href = url;
        a.download = `${getBaseFilename()}_part${index + 1}.png`;
        document.body.appendChild(a);
        a.click();
        setTimeout(() => {
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }, 100);
    }

    downloadAllBtn.addEventListener('click', () => {
        // Trigger downloads sequentially with slight delay to prevent browser blocking
        generatedBlobs.forEach((item, i) => {
            setTimeout(() => {
                 downloadSingle(item.blob, i);
            }, i * 300);
        });
    });

    newImageBtn.addEventListener('click', () => {
        loadedImage = null;
        fileInput.value = '';
        btn3H.disabled = true;
        btn3V.disabled = true;
        btnGrid.disabled = true;
        resetUIState();
        window.scrollTo(0,0);
    });

</script>

    <div id="promptModal" class="fixed inset-0 bg-black bg-opacity-50 hidden flex items-center justify-center z-50">
        <div class="bg-white p-6 rounded-lg max-w-lg w-full mx-4">
            <h2 class="text-xl font-bold mb-4">ðŸ¤– AI Prompt (Google Gemini)</h2>
            <pre id="promptText" class="whitespace-pre-wrap text-sm max-h-80 overflow-y-auto"></pre>
            <button onclick="closeModal()" class="mt-4 bg-red-500 text-white px-4 py-2 rounded">Close</button>
        </div>
    </div>

    <script>
        const prompts = {
            "photo_splitter": "Build an artifact that lets me split a photo into several subphotos of equal size.\n\nThere needs to be a field in which the user can select the photo (upload from computer or paste).\nThere needs to be a field with a template for name of resulting subphotos\n\nThen the user has three options to split the photos:\n3 photos horizontal split\n3 photos vertical split\n4 photos\n\nAfter one of these three options is selected the user will be able to review the result before each photo is saved (some guidelines will be overimposed to the original photoo). It will be possible to adjust the guidelines horizontally and vertically as appropriate)\n\nOnce reviewed it will be possible for the user to download each single photo. The name of the files will include the template provided previously by the user plus a string with time stamp to avoid duplications and overwriting existing files.\n\nNo React."
        };

        document.getElementById('viewPromptBtn').addEventListener('click', function() {
            document.getElementById('promptText').textContent = prompts.photo_splitter;
            document.getElementById('promptModal').classList.remove('hidden');
        });

        function closeModal() {
            document.getElementById('promptModal').classList.add('hidden');
        }
    </script>

</body>
</html>